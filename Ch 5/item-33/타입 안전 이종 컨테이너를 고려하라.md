# Item 33 - 타입 안전 이종 컨테이너를 고려하라

## 타입 안전 이종 컨테이너(Type Safe Heterogeneous Container)

`Set<E>`에는 하나의 타입 매개변수, `Map<K,V>`에는 두 개의 타입 매개변수를 활용하며 제네릭을 통해 타입 안전성을 보장하고 있다. 동일한 타입만 받도록 제약을 하려는 의도이니 문제될 것은 없지만 다양한 타입의 객체를 적재하는 컨테이너를 설계하고 싶을 경우 아쉬울 수 있다. `Object`를 타입 인자로 사용하면 다양한 타입을 받을 수 있지만 사용자는 꺼낼 때마다 매번 형변환을 해줘야하고 형변환에 실수하면 `ClassCastException`이 발생할 것이다. 다양한 타입의 객체를 적재할 수 있으면서 타입 안전성을 보장할 수 있다면 참 좋을 것이라는 생각이 드는데 타입 안전 이종 컨테이너 패턴을 활용하면 이를 가능하게 할 수 있다.

타입 안전 이종 컨테이너의 핵심은 컨테이너 대신 키를 매개변수화한 다음, 컨테이너에 값을 넣거나 뺄 때 매개변수화한 키를 함께 제공하는 것이다. `key`에 적재할 객체의 타입, `value`에 적재할 객체를 넘겨서 타입으로 객체를 요청하면 형변환이 된 객체를 응답받을 수 있다.

---

## Class 클래스

Class 클래스는 Java에서 클래스의 메타데이터를 다루는데 사용되는 클래스다. `.class` 문법을 활용하면 `Class<String> clazz = String.class` 이런식으로 타입을 값처럼 전달할 수 있다.(제네릭 정보는 소거된다.)

---

## 타입 안전 이종 컨테이너 예시

아래는 p.199의 코드 예시로 타입별로 즐겨 찾는 인스턴스를 저장하고 검색할 수 있는 `Favorites` 클래스다. `Favorites` 클래스는 `Map`을 통해 인스턴스에 대한 저장, 검색을 수행하는데 이때 key의 타입으로 `Class<?>`를 value의 타입으로 `Object`를 사용했다. 비한정적 와일드카드(`?`)를 사용하여 `key`에는 어떤 타입도 허용되면서, `Object`를 활용하며 `value`에도 어떤 인스턴스도 적재할 수 있다. `Map` 자체가 아니라 `Map`의 `key`에 비한정적 와일드카드가 있어서 어떤 타입이든 받을 수 있으면서 적재에도 문제가 없다.

```java
public class Favorites {
    private Map<Class<?>, Object> favorites = new HashMap<>();

    public <T> void putFavorite(Class<T> type, T instance) {
        favorites.put(Objects.requireNonNull(type), type.cast(instance));
    }

    public <T> T getFavorite(Class<T> type) {
        return type.cast(favorites.get(type));
    }
}
```

위처럼 `Favorites` 클래스를 정의하면 아래처럼 다양한 타입의 인스턴스를 잘 적재할 수 있다.

```java
    public static void main(String[] args) {
        Favorites f = new Favorites();

        f.putFavorite(String.class, "Java");
        f.putFavorite(Integer.class, 0xcafebabe);
        f.putFavorite(Class.class, Favorites.class);

        String favoriteString = f.getFavorite(String.class);
        Integer favoriteInteger = f.getFavorite(Integer.class);
        Class<?> favoriteClass = f.getFavorite(Class.class);

        System.out.printf("%s %x %s\n", favoriteString, favoriteInteger, favoriteClass.getName());
        // 출력 결과
        // Java cafebabe Favorites
    }
```

---

## 타입 토큰(Type Token), 슈퍼 타입 토큰(Super Type Token)

타입 토큰은 기존 타입 안전 이종 컨테이너에서 `key`로 활용한 타입 정보로 다양한 클래스들에서 잘 적용되는 것 같지만 한계는 있다. 바로 런타임에 소거되는 제네릭 정보는 넘길 수 없다는 점인데 아래 코드와 같이 기존의 타입 안전 이종 컨테이너는 `List<Integer>`와 `List<String>`을 구분하지 못한다.

```java
    public static void main(String[] args) {
        Favorites f = new Favorites();

        List<Integer> integerList = List.of(1, 2, 3, 4, 5);
        List<String> stringList = List.of("a", "b", "c", "d", "e", "f");

        f.putFavorite(List.class, integerList);  // List<Integer>.class 불가
        f.putFavorite(List.class, stringList);  // List<String>.class 불가

        List favorite = f.getFavorite(List.class);

        System.out.println(favorite);
        // 출력 결과
        // [a, b, c, d, e, f]
    }
```

이런 제네릭 정보까지 넘길 수 있는 타입 토큰이 슈퍼 타입 토큰으로 스프링 프레임워크의 `ParameterizedTypeReference` 클래스 등으로 구현되어 있다고는 하는데 교재에서는 어려워서 생략했다고 하고 나 역시 생략한다.

---

## 타입 안전 이종 컨테이너 활용 예시

스프링 프레임워크에서 타입 안전 이종 컨테이너가 활용된다고 한다. 타입으로 빈을 조회할 때 이런 타입 안전 이종 컨테이너를 통해 조회되었던 것 같다.

```java
class ApplicationContextBasicFindTest {

    AnnotationConfigApplicationContext ac = new AnnotationConfigApplicationContext(AppConfig.class);

    @Test
    @DisplayName("빈 이름으로 조회")
    void findBeanByName() {
        MemberService memberService = ac.getBean("memberService", MemberService.class);
        assertThat(memberService).isInstanceOf(MemberServiceImpl.class);
    }

    @Test
    @DisplayName("이름 없이 타입으로만 조회")
    void findBeanByType() {
        MemberService memberService = ac.getBean(MemberService.class);
        assertThat(memberService).isInstanceOf(MemberServiceImpl.class);
    }

    @Test
    @DisplayName("구체 타입으로 조회")
    void findBeanByName2() {
        MemberServiceImpl memberService = ac.getBean("memberService", MemberServiceImpl.class);
        assertThat(memberService).isInstanceOf(MemberServiceImpl.class);
    }

    @Test
    @DisplayName("빈 이름으로 조회X")
    void findBeanByNameX() {
        assertThrows(NoSuchBeanDefinitionException.class,
                () -> ac.getBean("xxxxx", MemberService.class));
    }
}
```

---
