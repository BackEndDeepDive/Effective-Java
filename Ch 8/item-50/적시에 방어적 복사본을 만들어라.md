# Item 50 - 적시에 방어적 복사본을 만들어라

## 들어가며
Java는 일반적으로 네이티브 메서드를 사용하는 C 계열 언어와 다르게 메모리 충돌 오류에서 안전하다. 하지만 아무리 Java라고 해도 다른 클래스로부터의 영향을 아예 받지 않는 것은 아니다. 따라서 클라이언트가 우리의 불변식을 깨트릴 때를 대비하여 방어적으로 프로그래밍 해야한다.

## 기간을 표현하는 클래스 Period

```java
// Broken "immutable" time period class (Pages 231-3)
public final class Period {
    private final Date start;
    private final Date end;

    /**
     * @param  start the beginning of the period
     * @param  end the end of the period; must not precede start
     * @throws IllegalArgumentException if start is after end
     * @throws NullPointerException if start or end is null
     */
    public Period(Date start, Date end) {
        if (start.compareTo(end) > 0)
            throw new IllegalArgumentException(
                    start + " after " + end);
        this.start = start;
        this.end   = end;
    }

    public Date start() {
        return start;
    }
    public Date end() {
        return end;
    }

    public String toString() {
        return start + " - " + end;
    }
```

기간을 표현하는 Period 클래스가 위와 같이 존재한다고 가정해보자. 얼핏보면 이 클래스는 불변처럼 보이고 시작 시간이 종료 시각보다 늦을 수 없는 불변식이 지켜지지만 Date가 가변한다는 사실을 이용하면 아래와 같은 end.setYear 메서드를 통해 불변식을 깨트릴 수 있다.

```java
// Attack the internals of a Period instance  (Page 232)
Date start = new Date();
Date end = new Date();
Period p = new Period(start, end);
end.setYear(78);  // Modifies internals of p!
```

## 첫 번째 공격: 생성자 매개변수 수정

위 공격은 Period 인스턴스를 생성한 후, 생성자에 넘긴 Date 객체를 외부에서 수정하여 Period의 내부를 변경하는 방식이다. 이를 막으려면 생성자에서 받은 가변 매개변수 각각을 방어적으로 복사(defensive copy) 해야 한다.
```java
// Repaired constructor - makes defensive copies of parameters (Page 232)
public Period(Date start, Date end) {
    this.start = new Date(start.getTime());
    this.end   = new Date(end.getTime());

    if (this.start.compareTo(this.end) > 0)
        throw new IllegalArgumentException(
                this.start + " after " + this.end);
}
```

방어적 복사을 사용할 때에는 다음과 같은 점을 고려해야한다.

1. 매개변수의 유효성을 검사하기 전에 방어적 복사본을 만든다
   - 유효성 검사 후 복사하면, 검사 시점과 복사 시점 사이에 다른 스레드가 원본 객체를 수정할 수 있다 (TOCTOU 공격: Time-Of-Check/Time-Of-Use)
   
2. 방어적 복사에 clone을 사용하지 않는다
   - Date는 final이 아니므로 clone이 Date의 하위 클래스 인스턴스를 반환할 수 있다
   - 하위 클래스가 악의적으로 설계되었다면 Period의 불변식을 깨뜨릴 수 있다

## 두 번째 공격: 접근자 메서드를 통한 공격

생성자를 수정했지만 Period 인스턴스는 여전히 변경 가능하다. 접근자 메서드가 내부의 가변 정보를 직접 드러내기 때문이다.
```java
// Second attack on the internals of a Period instance (Page 233)
Date start = new Date();
Date end = new Date();
Period p = new Period(start, end);
p.end().setYear(78);  // Modifies internals of p!
```

이 공격을 막으려면 가변 필드의 방어적 복사본을 반환해야 한다.
```java
// Repaired accessors - make defensive copies of internal fields (Page 233)
public Date start() {
    return new Date(start.getTime());
}

public Date end() {
    return new Date(end.getTime());
}
```

## 최종 Period 클래스

생성자와 접근자 모두 방어적 복사를 적용한 최종 코드는 다음과 같다.
```java
public final class Period {
    private final Date start;
    private final Date end;

    public Period(Date start, Date end) {
        // 방어적 복사본을 먼저 만든다
        this.start = new Date(start.getTime());
        this.end   = new Date(end.getTime());

        // 복사본으로 유효성 검사를 수행한다
        if (this.start.compareTo(this.end) > 0)
            throw new IllegalArgumentException(
                    this.start + " after " + this.end);
    }

    public Date start() {
        return new Date(start.getTime());
    }

    public Date end() {
        return new Date(end.getTime());
    }

    public String toString() {
        return start + " - " + end;
    }
}
```

이제 Period 인스턴스는 진정한 불변으로 어떠한 외부 공격으로부터도 안전하다.

## 방어적 복사의 생략

방어적 복사에는 아무래도 성능 저하가 있을 수 밖에 없고 항상 사용할 수 있는 것도 아니다. 따라서 다음의 경우 방어적 복사를 생략해도 된다.

1. 같은 패키지 내부에서만 사용되는 경우
2. 클라이언트가 객체를 잘못 수정하면 클라이언트만 피해를 입는 경우
   - Ex) 래퍼 클래스 패턴 (Item 18)
3. 메서드나 생성자의 매개변수로 넘기는 행위가 그 객체의 통제권을 이전함을 문서화한 경우
   - 통제권을 이전받은 메서드나 생성자는 그 객체를 더 이상 직접 수정하지 말아야 한다

## 불변 객체 사용한다면?

애초에 Date는 낡은 API이므로 새로운 코드를 작성할 때는 사용하지 말아야 한다. 대신 불변인 Instant(또는 LocalDateTime이나 ZonedDateTime)를 사용해서 아래와 같이 코드를 작성해야한다.

```java
public final class Period {
    private final Instant start;
    private final Instant end;

    public Period(Instant start, Instant end) {
        // 불변 객체는 방어적 복사가 필요x
        if (start.isAfter(end))
            throw new IllegalArgumentException(
                    start + " after " + end);
        this.start = start;
        this.end = end;
    }

    public Instant start() {
        return start; // 불변 객체는 그냥 반환해도 안전
    }

    public Instant end() {
        return end;
    }
}
```


## 마치며
클래스가 클라이언트로부터 받는 혹은 클라이언트로 반환하는 구성요소가 가변이라면 그 요소는 반드시 방어적으로 복사해야 한다. 하지만 복사 비용이 너무 크거나 클라이언트가 그 요소를 잘못 수정할 일이 없음이 확실하다면 방어적 복사를 수행하는 대신 해당 구성요소를 수정했을 때의 책임이 클라이언트에 있음을 문서에 명시해야한다. 결론적으로 가능하다면 불변 객체들을 조합해서 객체를 구성해야 방어적 복사를 효율적으로 사용하는 것이다.