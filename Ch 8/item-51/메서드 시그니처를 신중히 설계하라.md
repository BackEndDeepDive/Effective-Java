# Item 51 : 메서드 시그니처를 신중히 설계하라

### 1. 메서드 이름을 신중히 지어라

메서드 이름은 해당 메서드가 무엇을 하는지 명확히 전달해야 한다. **이름만 보고도 메서드의 동작을 예측할 수 있어야 한다.**

#### 표준 명명 규칙을 따르라

Java 커뮤니티에는 오랜 시간 동안 확립된 명명 규칙이 있다. 이를 따르면 다른 개발자들이 코드를 이해하기 쉬워진다.

```java
public class UserRepository {
    public User findById(Long id) { ... }
    public List<User> findAll() { ... }
    public void save(User user) { ... }
    public void delete(User user) { ... }
}

// 나쁜 예: 불명확하고 비표준적인 이름
public class UserRepository {
    public User get(Long id) { ... }  // 너무 일반적
    public void store(User user) { ... }  // 의미가 명확하지 않음
}
```

#### 일관성을 유지하라

같은 패키지나 라이브러리 내에서는 **일관된 명명 패턴** 을 유지해야 한다. 같은 동작을 하는 메서드는 같은 단어를 사용하라.

```java
public interface Collection<E> {
    int size();
    boolean isEmpty();
    boolean contains(Object o);
    Iterator<E> iterator();
    boolean add(E e);
    boolean remove(Object o);
}

// 나쁜 예: 일관성 없는 명명 패턴
public interface InconsistentCollection<E> {
    int getSize();              // size()와 혼용
    boolean empty();            // isEmpty()와 혼용
    boolean has(Object o);      // contains()와 혼용
    Iterator<E> getIterator();  // iterator()와 혼용
}
```

Java Collections Framework를 보면 `size()`, `isEmpty()`, `contains()` 같은 메서드가 모든 컬렉션에서 동일한 이름으로 제공된다. 이런 일관성 덕분에 개발자들은 새로운 컬렉션 타입을 접해도 빠르게 적응할 수 있다.

#### 긴 이름을 피하고, 너무 짧진 않게 작성

메서드 이름은 **명확성과 간결성 사이의 균형** 을 유지해야 한다. IDE의 자동완성 기능이 있다고 해서 지나치게 긴 이름을 사용하는 것은 좋지 않다.

```java
public User findByEmail(String email) { ... }
public void updatePassword(String newPassword) { ... }

// 너무 긴 이름
public User findUserByEmailAddressFromDatabase(String email) { ... }
public void updateUserPasswordInDatabaseWithValidation(String newPassword) { ... }

// 너무 짧은 이름
public User find(String e) { ... }  // 의미 불명확
public void update(String p) { ... }  // 의미 불명확
```

<br/>

### 2. 편의 메서드를 너무 많이 만들지 마라

클래스나 인터페이스는 **자신의 역할을 충실히 수행하는 메서드만 제공** 해야 한다. 메서드가 너무 많으면 이를 구현하고, 문서화하고, 테스트하고, 유지보수하기 어려워진다.

#### 핵심 기능에 집중하라

모든 조합 가능한 메서드를 제공하려 하지 말고, **기본적인 기능만 제공** 하라. 나머지는 사용자가 조합해서 만들 수 있다.

```java
public class Rectangle {
    private final double width;
    private final double height;
    
    public double getWidth() { return width; }
    public double getHeight() { return height; }
    public double getArea() { return width * height; }
    public double getPerimeter() { return 2 * (width + height); }
}

// 나쁜 예: 너무 많은 편의 메서드
public class Rectangle {
    private final double width;
    private final double height;
    
    public double getWidth() { return width; }
    public double getHeight() { return height; }
    public double getArea() { return width * height; }
    public double getPerimeter() { return 2 * (width + height); }
    public double getHalfArea() { return getArea() / 2; }
    public double getDoubleArea() { return getArea() * 2; }
    public double getAreaInSquareFeet() { return getArea() * 10.764; }
    public double getHalfPerimeter() { return getPerimeter() / 2; }
    public double getDiagonal() { return Math.sqrt(width * width + height * height); }
}
```

두 번째 예제의 `getHalfArea()`, `getDoubleArea()` 같은 메서드는 사용자가 `getArea() / 2`, `getArea() * 2`로 쉽게 구현할 수 있다. **자주 사용되는 경우에만** 편의 메서드를 제공하라.

#### 자주 사용되는 경우만 추가하라

편의 메서드를 추가할지 고민된다면 다음을 체크해보자
- 이 메서드가 정말 자주 사용되는가?
- 이 메서드가 없으면 사용자가 복잡한 코드를 작성해야 하는가?
- 이 메서드가 성능상 이점을 제공하는가?

```java
public final class String {
    public int length() { ... }
    public char charAt(int index) { ... }
    
    public boolean isEmpty() {
        return length() == 0;  // 단순하지만 매우 자주 사용됨
    }
    
    public boolean isBlank() {
        // 구현이 복잡하고 자주 사용되므로 제공
        return indexOfNonWhitespace() == length();
    }
}
```

<br/>

### 3. 매개변수 목록은 짧게 유지하라

**매개변수는 4개 이하** 가 이상적이다. 매개변수가 많아질수록 메서드를 사용하기 어려워지고, 실수할 가능성이 높아진다. 특히 **같은 타입의 매개변수** 가 여러 개 있으면 순서를 헷갈리기 쉽다.

#### 문제가 되는 긴 매개변수 목록

```java
// 나쁜 예: 매개변수가 너무 많고 같은 타입이 반복됨
public void createUser(
    String firstName,
    String lastName,
    String email,
    String phoneNumber,
    String address,
    String city,
    String state,
    String zipCode,
    int age,
    boolean isActive
) {

}

// 사용 시 순서를 헷갈리기 쉽다
createUser(
    "John",
    "Doe",
    "555-1234",         // email과 phoneNumber 순서가 바뀜
    "john@example.com", // 그래도 실행은 됨
    "123 Main St",
    "Springfield",
    "IL",
    "62701",
    30,
    true
);
```

위 예제의 문제는 **타입 시스템이 순서 오류를 잡아내지 못한다** 는 것이다. `email`과 `phoneNumber` 모두 `String`이므로 컴파일러는 순서가 바뀌어도 오류를 내지 않는다.

#### 해결 방법 1: 여러 메서드로 쪼개라

메서드가 여러 기능을 수행한다면 **각 기능을 담당하는 메서드로 분리** 하라.

```java
public class UserService {
    public User createBasicUser(String firstName, String lastName, String email) {
        // 기본 사용자 생성
    }
    
    public void updateContactInfo(User user, String phoneNumber, String email) {
        // 연락처 정보 업데이트
    }
    
    public void updateAddress(User user, Address address) {
        // 주소 정보 업데이트
    }
}
```

List 인터페이스의 `subList` 메서드는 좋은 예시다. 
![](https://velog.velcdn.com/images/kguswo/post/dd5db724-5dbd-4e9f-b582-467c49731ec8/image.png)


리스트의 부분을 다루는 모든 연산(찾기, 정렬, 복사 등)에 대해 각각의 메서드를 제공하는 대신, **부분 리스트를 반환하는 메서드 하나** 만 제공한다. 사용자는 이를 일반 리스트처럼 다루면 된다.

```java
List<String> list = new ArrayList<>(List.of("a", "b", "c", "d", "e"));

// subList 하나로 다양한 연산 가능
list.subList(1, 4).clear();                         // 부분 삭제
list.subList(0, 2).sort(Comparator.naturalOrder()); // 부분 정렬
```

#### 해결 방법 2: 매개변수 객체를 만들어라

**여러 매개변수를 묶어서 하나의 클래스로** 만들면 매개변수 개수를 줄이고, 코드의 가독성도 높일 수 있다.

```java
public class Address {
    private final String street;
    private final String city;
    private final String state;
    private final String zipCode;
    
    public Address(String street, String city, String state, String zipCode) {
        this.street = Objects.requireNonNull(street);
        this.city = Objects.requireNonNull(city);
        this.state = Objects.requireNonNull(state);
        this.zipCode = Objects.requireNonNull(zipCode);
    }
    // getters...
}

public class ContactInfo {
    private final String email;
    private final String phoneNumber;
    
    public ContactInfo(String email, String phoneNumber) {
        this.email = Objects.requireNonNull(email);
        this.phoneNumber = phoneNumber;  // 선택적
    }
    // getters...
}

public class UserService {
    public User createUser(
        String firstName,
        String lastName,
        ContactInfo contactInfo,
        Address address,
        int age
    ) {
        // 구현
    }
}

// 사용
User user = userService.createUser(
    "John",
    "Doe",
    new ContactInfo("john@example.com", "555-1234"),
    new Address("123 Main St", "Springfield", "IL", "62701"),
    30
);
```

매개변수 객체를 사용하면 **타입 안전성** 도 높아진다. `ContactInfo`와 `Address`는 서로 다른 타입이므로 순서를 바꾸면 컴파일 오류가 발생한다.

#### 해결 방법 3: 빌더 패턴을 사용하라

매개변수가 많고 대부분 선택적이라면 **빌더 패턴** 을 고려하라.

```java
// 좋은 예: 빌더 패턴
public class User {
    private final String firstName;   	// 필수
    private final String lastName;   	// 필수
    private final String email;      	// 필수
    private final String phoneNumber;   // 선택
    private final Address address;      // 선택
    private final int age;              // 선택
    private final boolean isActive;     // 선택
    
    private User(Builder builder) {
        this.firstName = builder.firstName;
        this.lastName = builder.lastName;
        this.email = builder.email;
        this.phoneNumber = builder.phoneNumber;
        this.address = builder.address;
        this.age = builder.age;
        this.isActive = builder.isActive;
    }
    
    public static class Builder {
        // 필수 매개변수
        private final String firstName;
        private final String lastName;
        private final String email;
        
        // 선택 매개변수 - 기본값으로 초기화
        private String phoneNumber = "";
        private Address address = null;
        private int age = 0;
        private boolean isActive = true;
        
        public Builder(String firstName, String lastName, String email) {
            this.firstName = Objects.requireNonNull(firstName);
            this.lastName = Objects.requireNonNull(lastName);
            this.email = Objects.requireNonNull(email);
        }
        
        public Builder phoneNumber(String val) {
            phoneNumber = val;
            return this;
        }
        
        public Builder address(Address val) {
            address = val;
            return this;
        }
        
        public Builder age(int val) {
            age = val;
            return this;
        }
        
        public Builder isActive(boolean val) {
            isActive = val;
            return this;
        }
        
        public User build() {
            return new User(this);
        }
    }
}

// 사용: 가독성이 뛰어남
User user = new User.Builder("John", "Doe", "john@example.com")
    .phoneNumber("555-1234")
    .age(30)
    .isActive(true)
    .build();

// 선택 매개변수는 생략 가능
User simpleUser = new User.Builder("Jane", "Smith", "jane@example.com")
    .build();
```

<br/>

### 4. 매개변수 타입으로는 클래스보다 인터페이스가 낫다

매개변수 타입을 정할 때는 **구체적인 클래스보다 인터페이스를 사용** 하라. 이렇게 하면 클라이언트가 더 유연하게 메서드를 사용할 수 있다.

```java
// 나쁜 예: 구체 클래스를 매개변수로 받음
public void processUsers(ArrayList<User> users) {
    for (User user : users) {
        process(user);
    }
}

// 사용 시 ArrayList만 전달 가능
ArrayList<User> arrayList = new ArrayList<>();
processUsers(arrayList);  // OK

LinkedList<User> linkedList = new LinkedList<>();
processUsers(linkedList);  // 컴파일 오류
```

위 코드는 `ArrayList`만 받을 수 있다. 클라이언트가 `LinkedList`나 다른 `List` 구현체를 사용하고 있다면 억지로 `ArrayList`로 변환해야 한다.

```java
public void processUsers(List<User> users) {
    for (User user : users) {
        process(user);
    }
}

// 모든 List 구현체 사용 가능
ArrayList<User> arrayList = new ArrayList<>();
processUsers(arrayList);

LinkedList<User> linkedList = new LinkedList<>();
processUsers(linkedList);

Vector<User> vector = new Vector<>();
processUsers(vector);
```

<br/>

### 5. boolean보다는 열거 타입을 사용하라

**boolean 매개변수는 메서드 호출 시 의미가 불명확** 하다. 코드를 읽는 사람은 `true`나 `false`가 무엇을 의미하는지 API 문서를 봐야 알 수 있다.

```java
public class Thermometer {
    public double getTemperature(boolean celsius) {
        // celsius가 true면 섭씨, false면 화씨
    }
}

double temp1 = thermometer.getTemperature(true);   // true가 뭔지 모름
double temp2 = thermometer.getTemperature(false);  // false가 뭔지 모름
```

호출 코드만 봐서는 `true`와 `false`가 무엇을 의미하는지 전혀 알 수 없다. API 문서를 보거나 메서드 정의로 이동해야 한다.

```java
public class Thermometer {
    public enum TemperatureUnit {
        CELSIUS, FAHRENHEIT
    }
    
    public double getTemperature(TemperatureUnit unit) {

    }
}

double temp1 = thermometer.getTemperature(TemperatureUnit.CELSIUS);
double temp2 = thermometer.getTemperature(TemperatureUnit.FAHRENHEIT);
```

열거 타입을 사용하면 **코드 자체가 문서 역할** 을 한다. IDE의 자동완성 기능도 사용할 수 있어 편리하다.

---

### References
- 이펙티브 자바 3/E