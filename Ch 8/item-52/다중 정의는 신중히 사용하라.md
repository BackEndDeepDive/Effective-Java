# Item 52 - 다중 정의는 신중히 사용하라
## 들어가며
다중 정의 즉 Overriding은 편리하지만 잘못 사용하면 우리가 생각하는 직관과 다르게 동작할 수 있다. 재정의 즉 Overriding과 달리 오버로딩은 컴파일타임에 어느 메서드를 호출할지 결정되므로 주의가 필요하다.

## 컬렉션 분류기

```java
// Broken! - What does this program print?  (Page 238)
public class CollectionClassifier {
    public static String classify(Set<?> s) {
        return "Set";
    }

    public static String classify(List<?> lst) {
        return "List";
    }

    public static String classify(Collection<?> c) {
        return "Unknown Collection";
    }

    public static void main(String[] args) {
        Collection<?>[] collections = {
                new HashSet<String>(),
                new ArrayList<BigInteger>(),
                new HashMap<String, String>().values()
        };

        for (Collection<?> c : collections)
            System.out.println(classify(c));
    }
}
```

위의 코드는 컬렉션을 Set, List와 그 이외의 것으로 구분하는 CollectionClassifier이다. 직관적으로 우리는 Set, List, Unknown Collection가 출력될 것 같지만 
실제로는 Unknown Collection만 세 번 출력된다. 그 이유는 오버로딩된 메서드 중 어떤 것을 사용할 지는 컴파일 타임에 정해지기 떄문이다. 런타임에는 타입이 매번 달라지지만 호출할 메서드를 선택하는 데는 영향을 주지 못하여 컴파일 타임의 매개변수를 기준으로 세 번째 메서드만 호출하는 것이다. 이처럼 직관과 어긋나는 이유는 오버라이딩 메서드는 동적으로 선택되고 오버로딩한 메서드는 정적으로 선택되기 떄문이다. 다음과 같은 예시를 다시 보자.

## 오버라이딩 메서드 호출 매커니즘
```java
class Wine {
    String name() { return "wine"; }
}

class SparklingWine extends Wine {
    @Override String name() { return "sparkling wine"; }
}

class Champagne extends SparklingWine {
    @Override String name() { return "champagne"; }
}

// Classification using method overrriding (Page 239)
public class Overriding {
    public static void main(String[] args) {
        List<Wine> wineList = List.of(
                new Wine(), new SparklingWine(), new Champagne());

        for (Wine wine : wineList)
            System.out.println(wine.name());
    }
}
```

이 코드에서는 wine, sparkling wine, champagne을 차례로 출력한다. for 문에서의 컴파일타임 타입이 모두 Wine인 것에 무관하게 항상 가장 하위에서 정의한 오버라이딩된 메서드가 실행되는 것이다. 한편 오버로딩된 메서드 사이에서는 객체의 런타임 타입은 전혀 중요하지 않다. 선택은 컴파일타임에 오직 매개변수의 컴파일타임 타입에 의해 이뤄진다.

위에 컬렉션 분류기에서 원래 의도대로 코드를 작성하려면 모든 classify 메서드를 하나로 합친 후 instanceof로 명시적으로 검사하면 된다.
```java
// Repaired static classifier method. (Page 240)
public static String classify(Collection c) {
    return c instanceof Set  ? "Set" :
           c instanceof List ? "List" : "Unknown Collection";
}
```
프로그래머에게는 오버라이딩이 정상적인 동작 방식이고, 오버로딩은 예외적인 동작으로 보일 것이다. 즉, 오버라이딩된 메서드는 프로그래머가 기대한 대로 동작하지만 클래스 분류기의 예시처럼 오버로딩은 기대한대로 동작하지 않을 가능성이 높다.

따라서 공개 API와 같이 사용자들이 조금이라도 헷갈릴 소지가 있다면 메서드를 오버로딩해야하는 것을 피해야한다. 안전하고 보수적으로 가려면 매개변수가 같은 오버로딩은 만들지 않는 것이 좋다. 오버로딩하는 대신 메서드 이름을 다르게 하는 방법도 있기 때문이다.

### 메서드 이름을 다르게 짓는 예시

`ObjectOutputStream` 클래스는 오버로딩이 아닌 모든 기본 타입과 일부 참조 타입용 변형을 가지고 있다.

```java
// ObjectOutputStream의 write 메서드들
writeBoolean(boolean)
writeByte(int)
writeShort(int)
writeChar(int)
writeInt(int)
writeLong(long)
writeFloat(float)
writeDouble(double)

// read 메서드도 동일한 패턴
readBoolean()
readByte()
readInt()
readLong()
...
```

이 방식이 오버로딩보다 나은 점은 read 메서드의 이름을 write와 짝을 맞추기 좋다는 것이다. 실제로도 `readInt()`와 `writeInt()`, `readLong()`과 `writeLong()` 같은 식으로 짝을 이룬다.

### 생성자의 경우

생성자는 이름을 다르게 지을 수 없으니 두 번째 생성자부터는 무조건 오버로딩이 된다. 하지만 정적 팩터리라는 대안을 활용할 수 있는 경우가 많다. 또한 생성자는 오버라이딩할 수 없으니 오버로딩과 오버라이딩이 혼용될 걱정은 없다. 그래도 여러 생성자가 같은 수의 매개변수를 받아야 하는 경우를 완전히 피할 수는 없으니 대책이 필요하다.

### 매개변수가 근본적으로 다른 경우

매개변수 수가 같은 오버로딩 메서드가 많더라도 그중 어느 것이 주어진 매개변수를 처리할지가 구분된다면 헷갈릴 일이 없다. 즉 매개변수 중 하나 이상이 근본적으로 다르다면 헷갈릴 일이 없다. 여기서 근본적으로 다르다는 것은*두 타입의 (null이 아닌) 값을 서로 어느 쪽으로든 형변환할 수 없다는 뜻인데 이 조건만 충족하면 어느 오버로딩 메서드를 호출할지가 매개변수들의 런타임 타입만으로 결정된다.

```java
public void setValue(int value) { ... }
public void setValue(String value) { ... }
```

Java 4까지는 모든 기본 타입이 모든 참조 타입과 근본적으로 달랐지만, Java 5에서 오토박싱이 도입되면서 문제가 발생하게 된다.

## 오토박싱과 오버로딩
```java
// Confusing use of overloading - Don't do this! (Page 241)
public class SetList {
    public static void main(String[] args) {
        Set set = new TreeSet<>();
        List list = new ArrayList<>();

        for (int i = -3; i < 3; i++) {
            set.add(i);
            list.add(i);
        }
        
        for (int i = 0; i < 3; i++) {
            set.remove(i);
            list.remove(i);
        }
        
        System.out.println(set + " " + list);
    }
}
```

이 코드는 [-3, -2, -1] [-3, -2, -1]을 출력할 것 같지만 실제로는 [-3, -2, -1] [-2, 0, 2]를 출력한다.

여기서 출력이 기대와 다르게 나온 이유는 다음과 같다.

1. set.remove(i)는 remove(Object)를 호출한다. 오토박싱으로 i가 `Integer`로 변환되어 기댓값인 0, 1, 2를 제거한다.
2. list.remove(i)`는 오버로딩된 remove(int index)를 호출한다. 즉, 인덱스 0, 1, 2번째 원소를 제거한다.

List 인터페이스에는 다음 두 메서드가 있다
```java
E remove(int index);           // 지정한 위치의 원소를 제거
boolean remove(Object o);      // 지정한 원소를 제거
```

제네릭이 도입되기 전인 Java 4까지는 `Object`와 `int`가 근본적으로 달라서 문제가 없었지만 제네릭과 오토박싱이 등장하면서 두 메서드의 매개변수 타입이 더는 근본적으로 다르지 않게 되었다.

### 해결 방법

list.remove의 인수를 Integer로 형변환하여 올바른 오버로딩 메서드를 선택하게 하면 된다.
```java
for (int i = 0; i < 3; i++) {
    set.remove(i);
    list.remove((Integer) i);  // 또는 list.remove(Integer.valueOf(i));
}
```

이제 프로그램은 [-3, -2, -1] [-3, -2, -1]을 출력한다.

이 예가 혼란스러웠던 이유는 `List<E>` 인터페이스가 `remove(Object)`와 `remove(int)`를 오버로딩했기 때문이다. 제네릭이 도입되기 전인 Java 4까지의 `List`에서는 `Object`와 `int`가 근본적으로 달라 문제가 없었지만 제네릭과 오토박싱이 등장하면서 문제가 발생한 것이다.

## 람다와 메서드 참조

Java 8에서 도입한 람다와 메서드 참조 또한 오버로딩 시 문제가 발생한다.

```java
// Broken! - What does this program print? (Page 241-2)
new Thread(System.out::println).start();

ExecutorService exec = Executors.newCachedThreadPool();
exec.submit(System.out::println);  // 컴파일 에러
```

1번과 2번이 모습은 비슷하지만 2번만 컴파일 에러가 난다. 넘겨진 인수는 모두 `System.out::println`으로 똑같고, 양쪽 모두 `Runnable`을 받는 형제 메서드를 오버로딩하고 있다.

여기서 에러가 발생하는 원인은 submit 오버로딩 메서드 중에는 Callable<T>를 받는 메서드도 있기 때문이다.

```java
// ExecutorService의 submit 메서드들
 Future submit(Callable task);
Future submit(Runnable task);
```

println 또한 오버로딩 되어있고 부정확한 메서드 참조인 System.out::println도 오버로딩된 메서드를 참조하고 있다. 그래서 오버로딩 해소 알고리즘이 이 메서드 참조가 정확히 어떤 메서드를 가리키는지 결정할 수 없어 컴파일 에러가 발생하는 것이다.

### 오버로딩 원칙

메서드를 오버로딩할 때 서로 다른 함수형 인터페이스라도 같은 위치의 인수로 받아서는 안 된다. 서로 다른 함수형 인터페이스라도 근본적으로 다르지 않다는 뜻이다.


자바 라이브러리에서는 이번 아이템에서 소개한 내용에 실패한 클래스도 몇 개 있다. `String` 클래스의 `valueOf(char[])`과 `valueOf(Object)`는 같은 객체를 건네더라도 전혀 다른 일을 수행한다. 이렇게 해야 할 이유가 없었지만 문제가 발생할 수도 있는 잘못된 사례로 남게 되었다.

## 마치며
프로그래밍 언어가 오버로딩을 허용한다고 해서 오버로딩을 꼭 활용하란 뜻은 아니고 매개변수의 수가 같을 때에는 오버로딩을 가급적 피하는 것이 좋다. 생성자라면 이 것이 불가능하기 때문에 헷갈릴만한 매개변수는 형변환해서 사용해야한다. 이것마저 불가능한 경우 같은 객체를 입력받는 오버로딩 메서드들이 모두 동일하게 동작하도록 만들어야한다.

